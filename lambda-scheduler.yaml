---
AWSTemplateFormatVersion: '2010-09-09'
Description: A Lambda function for scheduling later Lambda function executions.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Configuration
      Parameters:
      - MetricAlarmEmailAddress
      - LogRetentionDays
    ParameterLabels:
      LogRetentionDays:
        default: Log Retention (days)
      MetricAlarmEmailAddress:
        default: Alarm E-mail Address
Parameters:
  LogRetentionDays:
    Type: String
    Default: '14'
    AllowedValues:
    - ''
    - '1'
    - '3'
    - '5'
    - '7'
    - '14'
    - '30'
    - '60'
    - '90'
    - '120'
    - '150'
    - '180'
    - '365'
    - '400'
    - '545'
    - '731'
    - '1827'
    - '3653'
  MetricAlarmEmailAddress:
    Type: String
    Description: In case of errors. Leave blank to disable.
Mappings:
  StaticVariables:
    Main:
      StageName: v1
Conditions:
  IncludeMetricAlarmsCondition:
    Fn::Not:
    - Fn::Equals:
      - Ref: MetricAlarmEmailAddress
      - ''
Resources:
  
  #
  #   Invocation Queuer
  #   
  #   This is the function that receives requests to have Lambda functions 
  #   executed at a later time.
  #
  
  InvocationQueuerFunction:
    Type: AWS::Lambda::Function
    Metadata:
      SharedBucket:
        Ref: SharedBucket
    Properties:
      Description: Queues up Lambda function invocations for later execution.
      Handler: index.lambda_handler
      MemorySize: 128
      Role:
        Fn::GetAtt:
        - InvocationQueuerFunctionRole
        - Arn
      Code:
        ZipFile: |-
          from __future__ import print_function

          import json, datetime, time
          import boto3, botocore

          datetime_string_format = "%Y-%m-%dT%H:%M:%SZ"

          class LambdaHandler(object):

              def __init__(self, context):
                  self.s3_bucket = boto3.resource("s3").Bucket(self.get_s3_bucket_name())

              def handle_event(self, unvalidated_event, context):
                  print("Received event: {}".format(json.dumps(unvalidated_event)))

                  event = self.validate_event(unvalidated_event)
        
                  print("Validated event: {}".format(json.dumps(event)))
        
                  s3_pointer_content = {
                      "function-arn": event["function-arn"],
                      "payload": event["payload"],
                      "aws-request-id": context.aws_request_id,
                      "queued-function": context.function_name,
                      "queued-timestamp": int(time.time()),
                      "queued-log-group": context.log_group_name,
                      "queued-log-stream": context.log_stream_name
                  }

                  self.s3_bucket.put_object(
                      Body = json.dumps(s3_pointer_content, indent=4),
                      Key = "queued/{}/{}.json".format(
                          event["execution-time"],
                          context.aws_request_id
                      )
                  )

                  return {
                      "message": "Lambda invocation queued successfully."
                  }

              def validate_event(self, unvalidated_event):
                  clean_event = {}

                  execution_datetime = None
                  execution_time_specified = unvalidated_event.get("execution-time")
                  try:
                      execution_time_seconds = int(execution_time_specified)
                      execution_datetime = datetime.datetime.fromtimestamp(execution_time_seconds)
                  except:
                      pass

                  if execution_datetime is None:
                      raise Exception("Parameter \"{}\" must be specified as the number of seconds since UNIX epoch.".format("execution-time"))

                  clean_event["execution-time"] = execution_datetime.strftime(datetime_string_format)

                  lambda_function_arn = None
                  lambda_function_specified = unvalidated_event.get("function-name")
        
                  if lambda_function_specified is None:
                      raise Exception("Parameter \"{}\" must be specified as the name or ARN of a Lambda function.".format("function-name"))
        
                  lambda_client = boto3.client("lambda")
        
                  if lambda_function_specified is not None:
                      try:
                          response = lambda_client.get_function(
                              FunctionName = lambda_function_specified
                          )
                          lambda_function_arn = response["Configuration"]["FunctionArn"]
                      except botocore.exceptions.ClientError as e:
                          if e.response["Error"]["Code"] == "ResourceNotFoundException":
                              raise Exception("Function \"{}\" not found.".format(lambda_function_specified))
                          else:
                              raise
        
                  clean_event["function-arn"] = lambda_function_arn
        
                  lambda_payload = unvalidated_event.get("payload", {})
        
                  if not isinstance(lambda_payload, dict):
                      try:
                          lambda_payload = json.loads(lambda_payload)
                      except:
                          pass
        
                  if not isinstance(lambda_payload, dict):
                      raise Exception("Parameter \"{}\" must be specified as a JSON key/value struct (dictionary).".format("payload"))
        
                  clean_event["payload"] = lambda_payload
        
                  return clean_event

              def get_own_cloudformation_metadata(self):

                  if hasattr(self, "_own_cloudformation_metadata"):
                    return self._own_cloudformation_metadata

                  caller_arn = boto3.client("sts").get_caller_identity()["Arn"]
                  caller_role = caller_arn.split(":")[5].split("/")[1]

                  policy_response = boto3.client("iam").get_role_policy(
                      RoleName = caller_role,
                      PolicyName = "InvocationQueuerFunctionRoleActions"
                  )

                  this_stack_id = None

                  for each_statement in policy_response["PolicyDocument"]["Statement"]:
                    if len(each_statement.get("Action", [])) == 0:
                        continue

                    if each_statement["Action"][0].lower() == "cloudformation:describeStackResource".lower():
                        this_stack_id = each_statement["Resource"]
                        break

                  if this_stack_id is None:
                    raise Exception("Unable to determine CloudFormation stack ID from IAM policy.")

                  own_stack_resource = boto3.resource("cloudformation").StackResource(this_stack_id, "InvocationQueuerFunction")

                  own_metadata = json.loads(own_stack_resource.metadata)

                  print("Own CloudFormation metadata: {}".format(json.dumps(own_metadata)))

                  self._own_cloudformation_metadata = own_metadata

                  return own_metadata

              def get_s3_bucket_name(self):
                  return self.get_own_cloudformation_metadata()["SharedBucket"]


          handler_object = None
          def lambda_handler(event, context):
              global handler_object

              if handler_object is None:
                  handler_object = LambdaHandler(context)

              return handler_object.handle_event(event, context)
      Runtime: python2.7
      Timeout: '300'
  InvocationQueuerFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
  InvocationQueuerFunctionRoleActions:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: InvocationQueuerFunctionRoleActions
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource:
            Fn::Sub: arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${InvocationQueuerFunction}:log-stream:*
        - Effect: Allow
          Action:
          - s3:PutObject
          Resource:
            Fn::Sub: arn:aws:s3:::${SharedBucket}/queued/*
        - Effect: Allow
          Action:
          - iam:GetRolePolicy
          Resource:
            Fn::Sub: arn:aws:iam::${AWS::AccountId}:role/${InvocationQueuerFunctionRole}
        - Effect: Allow
          Action:
          - cloudformation:DescribeStackResource
          Resource:
            Fn::Sub: ${AWS::StackId}
        - Effect: Allow
          Action:
          - lambda:GetFunction
          - lambda:GetPolicy
          Resource:
            Fn::Sub: arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:*
      Roles:
      - Ref: InvocationQueuerFunctionRole
  InvocationQueuerFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /aws/lambda/${InvocationQueuerFunction}
      RetentionInDays:
        Ref: LogRetentionDays
  
  #
  #   Stack Setup Cleanup
  #   
  #   This function performs basic setup and cleanup functionality when the 
  #   stack is created / deleted.
  #   
  #   On create:
  #     - Nothing yet
  #   On delete:
  #     - Clear out S3 bucket
  #
  
  StackSetupCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Queues up Lambda function invocations for later execution.
      Handler: index.lambda_handler
      MemorySize: 1024
      Role:
        Fn::GetAtt:
        - StackSetupCleanupFunctionRole
        - Arn
      Code:
        ZipFile: |-
          from __future__ import print_function
          
          import json
          import boto3
          import cfnresponse
          
          class LambdaHandler(object):
          
              def __init__(self, context):
                  pass
            
              def handle_event(self, event, context):
                  print("Event: {}".format(json.dumps(event)))
                  
                  request_type = event.get("RequestType")
                  
                  if request_type == "Create":
                      self.handle_setup_event(event, context)
                  elif request_type == "Delete":
                      self.handle_cleanup_event(event, context)
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  
                  return {}
              
              def handle_setup_event(self, event, context):
                  return
              
              def handle_cleanup_event(self, event, context):
                  
                  s3_client = boto3.client("s3")
                  s3_bucket_name = event["ResourceProperties"]["SharedBucket"]
                  
                  paginator = s3_client.get_paginator("list_objects_v2")
                  
                  response_iterator = paginator.paginate(
                    Bucket = s3_bucket_name
                  )
                  
                  for each_list_response in response_iterator:
                    keys_to_delete = []
                    
                    for each_item in each_list_response.get("Contents", []):
                        keys_to_delete.append(each_item["Key"])
                    
                    if len(keys_to_delete) == 0:
                        print("Last request for objects in {} returned none.".format(
                            s3_bucket_name
                        ))
                        break
                    
                    print("Deleting {} object(s) from {}.".format(
                        len(keys_to_delete),
                        s3_bucket_name
                    ))
                    
                    s3_client.delete_objects(
                        Bucket = s3_bucket_name,
                        Delete = {
                            "Objects": list({"Key": x} for x in keys_to_delete)
                        }
                    )
                    
                    print("Object(s) deleted.")
          
          handler_object = None
          def lambda_handler(event, context):
              global handler_object
              
              if handler_object is None:
                  handler_object = LambdaHandler(context)
              
              return handler_object.handle_event(event, context)
      Runtime: python2.7
      Timeout: '300'
  StackSetupCleanupFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
  StackSetupCleanupFunctionRoleActions:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: StackSetupCleanupFunctionRoleActions
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource:
            Fn::Sub: arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${StackSetupCleanupFunction}:log-stream:*
        - Effect: Allow
          Action:
          - s3:DeleteObject
          Resource:
            Fn::Sub: arn:aws:s3:::${SharedBucket}/*
        - Effect: Allow
          Action:
          - s3:ListBucket
          Resource:
            Fn::Sub: arn:aws:s3:::${SharedBucket}
      Roles:
      - Ref: StackSetupCleanupFunctionRole
  StackSetupCleanupFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /aws/lambda/${StackSetupCleanupFunction}
      RetentionInDays:
        Ref: LogRetentionDays
  StackSetupCleanupInvocation:
    Type: Custom::StackSetupCleanupInvocation
    Properties:
      ServiceToken:
        Fn::GetAtt:
        - StackSetupCleanupFunction
        - Arn
      SharedBucket:
        Ref: SharedBucket
    DependsOn:
    - StackSetupCleanupFunctionLogGroup
    - StackSetupCleanupFunctionRoleActions
  
  SharedBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
        
Outputs:
  WordGeneratorApiEndPoint:
    Value: test
